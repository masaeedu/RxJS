import {Observable} from './Observable';
import {Scheduler} from './Scheduler';
import {ConnectableObservable} from './observable/ConnectableObservable';
import {Subject} from './Subject';
import {GroupedObservable} from './operator/groupBy-support';
import {Notification} from './Notification';

import {buffer} from './operator/buffer';
import {bufferCount} from './operator/bufferCount';
import {bufferTime} from './operator/bufferTime';
import {bufferToggle} from './operator/bufferToggle';
import {bufferWhen} from './operator/bufferWhen';
import {_catch} from './operator/catch';
import {combineAll} from './operator/combineAll';
import {combineLatest} from './operator/combineLatest';
import {concat} from './operator/concat';
import {concatAll} from './operator/concatAll';
import {concatMap} from './operator/concatMap';
import {concatMapTo} from './operator/concatMapTo';
import {count} from './operator/count';
import {dematerialize} from './operator/dematerialize';
import {debounce} from './operator/debounce';
import {debounceTime} from './operator/debounceTime';
import {defaultIfEmpty} from './operator/defaultIfEmpty';
import {delay} from './operator/delay';
import {distinctUntilChanged} from './operator/distinctUntilChanged';
import {_do} from './operator/do';
import {expand} from './operator/expand';
import {filter} from './operator/filter';
import {_finally} from './operator/finally';
import {first} from './operator/first';
import {groupBy} from './operator/groupBy';
import {ignoreElements} from './operator/ignoreElements';
import {last} from './operator/last';
import {every} from './operator/every';
import {map} from './operator/map';
import {mapTo} from './operator/mapTo';
import {materialize} from './operator/materialize';
import {merge} from './operator/merge';
import {mergeAll} from './operator/mergeAll';
import {mergeMap} from './operator/mergeMap';
import {mergeMapTo} from './operator/mergeMapTo';
import {multicast} from './operator/multicast';
import {observeOn} from './operator/observeOn';
import {partition} from './operator/partition';
import {publish} from './operator/publish';
import {publishBehavior} from './operator/publishBehavior';
import {publishReplay} from './operator/publishReplay';
import {publishLast} from './operator/publishLast';
import {reduce} from './operator/reduce';
import {repeat} from './operator/repeat';
import {retry} from './operator/retry';
import {retryWhen} from './operator/retryWhen';
import {sample} from './operator/sample';
import {sampleTime} from './operator/sampleTime';
import {scan} from './operator/scan';
import {share} from './operator/share';
import {single} from './operator/single';
import {skip} from './operator/skip';
import {skipUntil} from './operator/skipUntil';
import {skipWhile} from './operator/skipWhile';
import {startWith} from './operator/startWith';
import {subscribeOn} from './operator/subscribeOn';
import {_switch} from './operator/switch';
import {switchMap} from './operator/switchMap';
import {switchMapTo} from './operator/switchMapTo';
import {take} from './operator/take';
import {takeUntil} from './operator/takeUntil';
import {takeWhile} from './operator/takeWhile';
import {throttle} from './operator/throttle';
import {throttleTime} from './operator/throttleTime';
import {timeout} from './operator/timeout';
import {timeoutWith} from './operator/timeoutWith';
import {toArray} from './operator/toArray';
import {toPromise} from './operator/toPromise';
import {window} from './operator/window';
import {windowCount} from './operator/windowCount';
import {windowTime} from './operator/windowTime';
import {windowToggle} from './operator/windowToggle';
import {windowWhen} from './operator/windowWhen';
import {withLatestFrom} from './operator/withLatestFrom';
import {zipProto} from './operator/zip';
import {zipAll} from './operator/zipAll';

export interface CoreOperators<T> {
  buffer?: buffer<T>;
  bufferCount?: bufferCount<T>;
  bufferTime?: bufferTime<T>;
  bufferToggle?: bufferToggle<T>;
  bufferWhen?: bufferWhen<T>;
  catch?: _catch<T>;
  combineLatest?: combineLatest<T>;
  concat?: concat<T>;
  concatMap?: concatMap<T>;
  concatMapTo?: concatMapTo<T>;
  count?: count<T>;
  debounce?: debounce<T>;
  debounceTime?: debounceTime<T>;
  defaultIfEmpty?: defaultIfEmpty<T>;
  delay?: delay<T>;
  distinctUntilChanged?: distinctUntilChanged<T>;
  do?: _do<T>;
  expand?: expand<T>;
  filter?: filter<T>;
  finally?: _finally<T>;
  first?: first<T>;
  flatMap?: mergeMap<T>;
  flatMapTo?: mergeMapTo<T>;
  groupBy?: groupBy<T>;
  ignoreElements?: ignoreElements<T>;
  last?: last<T>;
  every?: every<T>;
  map?: map<T>;
  mapTo?: mapTo<T>;
  materialize?: materialize<T>;
  merge?: merge<T>;
  mergeMap?: mergeMap<T>;
  mergeMapTo?: mergeMapTo<T>;
  multicast?: multicast<T>;
  observeOn?: observeOn<T>;
  partition?: partition<T>;
  publish?: publish<T>;
  publishBehavior?: publishBehavior<T>;
  publishReplay?: publishReplay<T>;
  publishLast?: publishLast<T>;
  reduce?: reduce<T>;
  repeat?: repeat<T>;
  retry?: retry<T>;
  retryWhen?: retryWhen<T>;
  sample?: sample<T>;
  sampleTime?: sampleTime<T>;
  scan?: scan<T>;
  share?: share<T>;
  single?: single<T>;
  skip?: skip<T>;
  skipUntil?: skipUntil<T>;
  skipWhile?: skipWhile<T>;
  startWith?: startWith<T>;
  subscribeOn?: subscribeOn<T>;
  switchMap?: switchMap<T>;
  switchMapTo?: switchMapTo<T>;
  take?: take<T>;
  takeUntil?: takeUntil<T>;
  takeWhile?: takeWhile<T>;
  throttle?: throttle<T>;
  throttleTime?: throttleTime<T>;
  timeout?: timeout<T>;
  timeoutWith?: timeoutWith<T>;
  toArray?: toArray<T>;
  toPromise?: toPromise<T>;
  window?: window<T>;
  windowCount?: windowCount<T>;
  windowTime?: windowTime<T>;
  windowToggle?: windowToggle<T>;
  windowWhen?: windowWhen<T>;
  withLatestFrom?: withLatestFrom<T>;
  zip?: zipProto<T>;
}

export interface NestedObservableOperators<T extends Observable<U>, U> {
  combineAll?: combineAll<T, U>;
  concatAll?: concatAll<T, U>;
  mergeAll?: mergeAll<T, U>;
  zipAll?: zipAll<T, U>;
  switch?: _switch<T, U>;
}

export interface MaterializedObservableOperators<T extends Notification<U>, U> {
  dematerialize?: dematerialize<T, U>;
}